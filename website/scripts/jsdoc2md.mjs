import path from 'path';
import chalk from 'chalk';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { globby } from 'globby';
import jsdoc2md from 'jsdoc-to-markdown';

const GIT_BASE_URL =
  'https://github.com/seznam/ima/tree/next/packages/core/src';
const DOC_PREPROCESSORS = [
  {
    pattern:
      /\/[*][*]((?:a|[^a])*?)@(type|param|return)\s*[{]([^}]*?)([a-zA-Z0-9_., *<>|]+)\[\]([^}]*)[}]((a|[^a])*)[*]\//g,
    replace: '/**$1@$2 {$3Array<$4>$5}$6*/',
  },
  {
    pattern: /^\sexport\s+\{([\s\S.]+)\};?/gm,
    replace: '',
  },
  {
    pattern: /^\s*(export\s+default|export)\s+/gm,
    replace: '',
  },
  {
    pattern: /@private/gm,
    replace: '',
  },
];

const dirname = fileURLToPath(path.dirname(import.meta.url));
const outputBaseDir = path.resolve(dirname, '../../docs/api');
const partialsDir = path.resolve(dirname, './partials/');

/**
 * Creates Category item metadata index file at base of each
 * nested directory with custom label and additional metadata
 * used in autogenerated docusaurus sidebar.
 */
async function createCategoryIndex(baseDir, depth) {
  const categoryItemPath = path.join(baseDir, '_category_.json');

  if (fs.existsSync(categoryItemPath)) {
    return;
  }

  let label = baseDir.split(path.sep).pop();
  label = `${label.charAt(0).toUpperCase()}${label.slice(1)}`;

  return fs.promises.writeFile(
    categoryItemPath,
    JSON.stringify({
      label,
      collapsible: true,
      collapsed: depth > 2,
      link: null,
    })
  );
}

/**
 * Runs preprocessors on file contents to prepare them for
 * better JSdoc generated output.
 */
function preprocess(content) {
  let oldContent = null;

  while (content !== oldContent) {
    oldContent = content;
    for (let preprocessor of DOC_PREPROCESSORS) {
      let { pattern, replace } = preprocessor;
      content = content.replace(pattern, replace);
    }
  }

  return content;
}

/**
 * Generates docs/api markdown files and folder structure
 * that is loaded in docusaurus.
 */
async function main() {
  console.log(
    `${chalk.bold.cyan(
      'GENERATING'
    )} the API jsdoc documentation markdown files.`
  );

  // Cleanup output dir
  await fs.promises.rm(outputBaseDir, { recursive: true, force: true });
  await fs.promises.mkdir(outputBaseDir, { recursive: true });

  // Init jsdoc2md config
  const config = {
    separators: true,
    'global-index-format': 'grouped',
    'member-index-format': 'list',
    'property-list-format': 'list',
    partial: [
      path.join(partialsDir, 'docs.hbs'),
      path.join(partialsDir, 'header.hbs'),
      path.join(partialsDir, 'main.hbs'),
    ],
  };

  const pkgBasePath = path.resolve(dirname, '../../packages/core/src');
  const files = await globby([
    path.join(pkgBasePath, '**/*.(js|jsx)'),
    `!*/**/__tests__`,
  ]);

  // Generate markdown files
  await Promise.all(
    files.filter(Boolean).map(async file => {
      const { name: fileName } = path.parse(file);
      const relativePath = path.relative(pkgBasePath, file);

      // Run preprocessors on the file contents
      const source = preprocess(
        await (await fs.promises.readFile(file)).toString()
      );

      // Generate template data
      const templateData = (
        await jsdoc2md.getTemplateData({
          source,
        })
      ).map(item => {
        if (item.meta) {
          const { lineno = 1 } = item.meta;

          item.imaGitUrl = `${GIT_BASE_URL}/${relativePath}#L${lineno}`;
        }

        return item;
      });

      if (!templateData.length) {
        return;
      }

      // Assign additional template metadata
      templateData.meta = {
        sidebarLabel: fileName.split('.')[0],
      };

      const { dir: relativeDir } = path.parse(relativePath);
      const docOutputDir = path.join(outputBaseDir, relativeDir);

      // Convert jsdoc metdata to markdown
      let markdownContents = await jsdoc2md.render({
        ...config,
        data: templateData,
      });

      // Write md file and create directory structure
      await fs.promises.mkdir(docOutputDir, { recursive: true });
      await fs.promises.writeFile(
        path.join(docOutputDir, `${fileName}.md`),
        markdownContents
      );

      // Create category item metadata index file
      if (relativeDir) {
        await createCategoryIndex(
          docOutputDir,
          relativeDir.split(path.sep).length
        );
      }
    })
  );

  console.log(
    `${chalk.bold.green(
      'FINISHED'
    )}, the documentation files were generated successfully.`
  );
}

main();
