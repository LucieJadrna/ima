import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { globby } from 'globby';
import jsdoc2md from 'jsdoc-to-markdown';

const GIT_BASE_URL =
  'https://github.com/seznam/ima/tree/next/packages/core/src';

const dirname = fileURLToPath(path.dirname(import.meta.url));
const outputBaseDir = path.resolve(dirname, '../../docs/api');
const partialsDir = path.resolve(dirname, './partials/');

/**
 * Creates Category item metadata index file at base of each
 * nested directory with custom label and additional metadata
 * used in autogenerated docusaurus sidebar.
 */
async function createCategoryIndex(baseDir, depth) {
  const categoryItemPath = path.join(baseDir, '_category_.json');

  if (fs.existsSync(categoryItemPath)) {
    return;
  }

  let label = baseDir.split(path.sep).pop();
  label = `${label.charAt(0).toUpperCase()}${label.slice(1)}`;

  return fs.promises.writeFile(
    categoryItemPath,
    JSON.stringify({
      label,
      collapsible: true,
      collapsed: depth > 2,
      link: null,
    })
  );
}

async function main() {
  // Create clean output dir
  await fs.promises.rm(outputBaseDir, { recursive: true, force: true });
  await fs.promises.mkdir(outputBaseDir, { recursive: true });

  // Init jsdoc2md config
  const config = {
    separators: true,
    'global-index-format': 'grouped',
    'member-index-format': 'list',
    'property-list-format': 'list',
    partial: [
      path.join(partialsDir, 'docs.hbs'),
      path.join(partialsDir, 'header.hbs'),
      path.join(partialsDir, 'main.hbs'),
    ],
  };

  const pkgBasePath = path.resolve(dirname, '../../packages/core/src');
  const files = await globby([
    path.join(pkgBasePath, '**/*.(js|jsx)'),
    `!*/**/__tests__`,
  ]);

  // Generate markdown files
  await Promise.all(
    files.map(async file => {
      const rootTemplateData = {};
      const templateData = (
        await jsdoc2md.getTemplateData({
          files: file,
        })
      ).map(item => {
        if (item.meta) {
          const { filename, lineno = 1, path: itemPath } = item.meta;
          const itemRelativePath = path.relative(pkgBasePath, itemPath);

          item.imaGitUrl = `${GIT_BASE_URL}/${itemRelativePath}/${filename}#L${lineno}`;
          item.meta.relativePath = itemRelativePath;

          // Parse sidebar metadata
          rootTemplateData.sidebarLabel = filename.split('.')[0];
        } else {
          rootTemplateData.sidebarLabel = item.id;
        }

        return item;
      });

      if (!templateData.length) {
        return;
      }

      // Assign root template data
      templateData.meta = rootTemplateData;

      const relativePath = path.relative(pkgBasePath, file);
      const { name, dir } = path.parse(relativePath);
      const docOutputDir = path.join(outputBaseDir, dir);

      // Convert jsdoc metdata to markdown
      let markdownContents = await jsdoc2md.render({
        ...config,
        data: templateData,
      });

      // Write md file and create directory structure
      await fs.promises.mkdir(docOutputDir, { recursive: true });
      await fs.promises.writeFile(
        path.join(docOutputDir, `${name}.md`),
        markdownContents
      );

      // Create category item metadata index file
      if (dir) {
        await createCategoryIndex(docOutputDir, dir.split(path.sep).length);
      }
    })
  );
}

main();
